<?php
// $Id: series.module,v 1.5 2010/07/27 15:20:50 greenskin Exp $

/**
 * @file
 * Provides the ability to tie nodes into series.
 *
 * @author greenSkin
 */

/**
 * Implementation of hook_perm().
 */
function series_perm() {
  return array('view all series', 'edit own series', 'edit any series');
}

/**
 * Implementation of hook_menu().
 */
function series_menu() {
  $items['admin/settings/series'] = array(
    'title' => 'Series',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('series_admin_form'),
    'access arguments' => array('administer series'),
    'file' => 'series.admin.inc'
  );
  $items['node/%series_node/edit/general'] = array(
    'title' => 'General',
    'page callback' => 'node_page_edit',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0
  );
  $items['node/%series_node/edit/series'] = array(
    'title' => 'Series',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('series_node_edit_form', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'series.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1
  );
  $items['series/%series/edit'] = array(
    'title' => 'Series',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('series_edit_form', 1),
    'access callback' => 'series_access',
    'access arguments' => array(1),
    'file' => 'series.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1
  );
  return $items;
}

/**
 * Implementation of hook_form_alter().
 */
function series_form_alter(&$form, &$form_state, $form_id) {
  // Ensure this is a node form.
  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    // Ensure this node type is using the series vocabulary.
    $vocabulary = taxonomy_vocabulary_load(variable_get('series_vid', 0));
    if ($vocabulary && in_array($form['type']['#value'], $vocabulary->nodes)) {
      // If series query string exists, set the series input and disable it so
      // it can't be changed.
      if (isset($_REQUEST['series']) && is_numeric($_REQUEST['series'])) {
        $term = taxonomy_get_term($_REQUEST['series']);
        if ($term && $term->vid == $vocabulary->vid) {
          if (isset($form['taxonomy']['tags']) && isset($form['taxonomy']['tags'][$term->vid])) {
            $element = &$form['taxonomy']['tags'][$term->vid];
            $element['#value'] = $term->name;
            $element['#disabled'] = TRUE;
            unset($element['#autocomplete_path']);
          }
          else if (isset($form['taxonomy'][$term->vid])) {
            $element = &$form['taxonomy'][$term->vid];
            $element['#value'] = $term->tid;
            $element['#disabled'] = TRUE;
          }
        }
      }

      // Set a submit function that redirects to the series edit page.
      $form['#submit'][] = 'series_node_edit_redirect_submit';
    }
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function series_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  if ($form['vid']['#value'] == variable_get('series_vid', 0)) {
    $form['settings']['#description'] = t('This vocabulary is chosen as the !link, and as such the multiple select field have been disabled.', array('!link' => l(t('Lesson Series vocabulary'), 'admin/settings/lesson/series')));
    $form['settings']['multiple']['#type'] = 'hidden';
    $form['settings']['multiple']['#value'] = 0;
    $form['#submit'][] = 'series_taxonomy_form_vocabulary_submit';
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function series_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'view':
      // If we are not a teaser show applicable next/previous links to other
      // nodes in this nodes series.
      if ($a3 == FALSE) {
        if ($series = series_load($node)) {
          list($prev, $next) = series_navigation_links($series, $node);

          if ($prev) {
            $node->content['series_navigation']['previous'] = array(
              '#value' => l(t('Previous'), 'node/'. $prev['nid']),
              '#weight' => -1
            );
          }

          if ($next) {
            $node->content['series_navigation']['next'] = array(
              '#value' => l(t('Next'), 'node/'. $next['nid']),
              '#weight' => 1
            );
          }
        }
      }
      break;
  }
}

/**
 * Implementation of hook_theme().
 */
function series_theme() {
  return array(
    'series_edit_form' => array(
      'arguments' => array('form' => NULL)
    ),
    'series_create_form' => array(
      'arguments' => array('form' => NULL)
    )
  );
}

/**
 * Implementation of hook_flush_caches().
 */
function series_flush_caches() {
  return array('cache_series');
}

/**
 * Implementation of hook_views_api().
 */
function series_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'series') .'/views'
  );
}

function series_access($series, $account = NULL) {
  global $user;
  static $access = array();

  if (!isset($account)) {
    $account = $user;
  }

  if (user_access('edit any series', $account)) {
    return TRUE;
  }

  if (!isset($access[$series->tid][$account->uid])) {
    // Default access to false.
    $access[$series->tid][$account->uid] = FALSE;

    if (user_access('edit own series', $account)) {
      // Look to see if the account has created a node within this series.
      foreach ($series->nodes as $node) {
        $uid = db_result(db_rewrite_sql('SELECT n.uid FROM {node} AS n WHERE n.nid = %d', $node['nid']));
        if ($uid == $account->uid) {
          $access[$series->tid][$account->uid] = TRUE;
          break;
        }
      }
    }
  }

  return $access[$series->tid][$account->uid];
}

function series_node_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }
  $node = node_load($nid);
  if (isset($node->type)) {
    $vocabulary = taxonomy_vocabulary_load(variable_get('series_vid', 0));
    if ($vocabulary && in_array($node->type, $vocabulary->nodes)) {
      if ($series = series_load($node)) {
        return $node;
      }
    }
  }
  return FALSE;
}

function series_load($param) {
  static $series = array();

  if (is_object($param)) {
    // Only node objects.
    if (isset($param->nid) && $param->nid > 0) {
      if (!isset($series['node'][$param->nid])) {
        $series['node'][$param->nid] = _series_load_node_series($param);
      }
      return $series['node'][$param->nid];
    }
    return FALSE;
  }

  $tid = $param;
  if (!isset($series['term'][$tid])) {
    // Grab cached if exists.
    if ($cache = cache_get('series:'. $tid, 'cache_series')) {
      $term_series = $cache->data;
    }
    else {
      $term_series = taxonomy_get_term($tid);

      if (!empty($term_series)) {
        // Build array of nodes tied to this series.
        $term_series->nodes = array();
        $result = taxonomy_select_nodes(array($tid));
        while ($data = db_fetch_array($result)) {
          // Specify the node's type.
          $data['type'] = db_result(db_query("SELECT type FROM {node} WHERE nid = %d", $data['nid']));

          // Get the weight of the node in the series.
          $data['weight'] = (int)db_result(db_query("SELECT weight FROM {series_weight} WHERE tid = %d AND nid = %d", $tid, $data['nid']));

          $term_series->nodes[$data['nid']] = $data;
        }
        // Sort the nodes.
        uasort($term_series->nodes, 'series_sort');

        // Save to cache.
        cache_set('series:'. $tid, $term_series, 'cache_series');
      }
      else {
        $term_series = FALSE;
      }
    }

    $series['term'][$tid] = $term_series;
  }
  return $series['term'][$tid];
}

function series_node_edit_redirect_submit($form, &$form_state) {
  if ($form_state['values']['nid']) {
    $vid = variable_get('series_vid', 0);
    if (isset($form_state['values']['taxonomy']['tags']) && isset($form_state['values']['taxonomy']['tags'][$vid])) {
      $term = $form_state['values']['taxonomy']['tags'][$vid];
    }
    else if (isset($form_state['values']['taxonomy'][$vid])) {
      $term = $form_state['values']['taxonomy'][$vid];
    }

    if (isset($term) && $term != NULL) {
      // $form_state['redirect'] does not work here since the node module forces
      // a redirect back to the node view page, however the destination query
      // redirect works so we use that.
      $_REQUEST['destination'] = 'node/'. $form_state['values']['nid'] .'/edit/series';
    }
  }
}

function series_taxonomy_form_vocabulary_submit($form, &$form_state) {
  cache_clear_all('*', 'cache_series');
}

function series_navigation_links($series, $node) {
  // Ensure the pointer is at the beginning of the array.
  reset($series->nodes);

  $current = current($series->nodes);

  // Loop through the series nodes, moving the array pointer 'till we find the
  // requested node.
  while ($current && $current['nid'] != $node->nid) {
    $current = next($series->nodes);
  }

  // Move the array pointer back one to assign the previous node.
  $prev = prev($series->nodes);
  // Move the array pointer ahead one again to the current node. If there was
  // not a previous element in the array, we do not need to use next() to
  // return to the current position instead we reset().
  ($prev) ? next($series->nodes) : reset($series->nodes);
  // Move the array pointer ahead one more to assign the next node.
  $next = next($series->nodes);

  return array($prev, $next);
}

/**
 * Helper function to sort nodes within a series.
 */
function series_sort($a, $b) {
  if ($a['weight'] == $b['weight']) {
    return 0;
  }
  return ($a['weight'] < $b['weight']) ? -1 : 1;
}

function _series_load_node_series($node) {
  if ($vid = variable_get('series_vid', 0)) {
    if (isset($node->taxonomy)) {
      // Process terms differently based on if terms have been converted
      // after a preview.
      if (is_array(current($node->taxonomy))) {
        return series_load($node->taxonomy[$vid]);
      }
      else {
        foreach ($node->taxonomy as $term) {
          if ($term->vid == $vid) {
            return series_load($term->tid);
          }
        }
      }
    }
  }
}
